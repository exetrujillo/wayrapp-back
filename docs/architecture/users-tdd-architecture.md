# Arquitectura TDD de Usuarios - Flujo de Implementaci√≥n

## Resumen

Este documento describe la arquitectura de Desarrollo Dirigido por Pruebas (TDD) para implementar la gesti√≥n de datos de usuarios en nuestro sistema multi-base de datos. La arquitectura sigue los principios de Clean Architecture con un dise√±o agn√≥stico de base de datos que soporta PostgreSQL y MySQL usando Prisma como ORM √∫nico.

## Diagrama de Flujo de Implementaci√≥n

```mermaid
graph TD
    %% TDD Cycle: RED - GREEN - REFACTOR

    %% Phase 1: Domain & Contracts (RED)
    A[Definir Interfaces y Entidades de Dominio] --> B[IUserRepository Interface]
    B --> C[Escribir Tests de Contrato]
    C --> D[makeUserRepositoryContractTest]
    D --> E[Tests FAIL - RED State]

    %% Phase 2: Implementation (GREEN)
    E --> F[Implementar UserRepository con Prisma]
    F --> G[Correr Tests de Integraci√≥n vs PostgreSQL]
    G --> H[Tests PASS vs PostgreSQL - GREEN State]

    %% Phase 3: Validation & Refactor (VALIDATE & REFACTOR)
    H --> I[Correr MISMOS Tests vs MySQL con Prisma]
    I --> J[Tests PASS vs MySQL - VALIDATED State]
    J --> K[Refactorizar UserRepository con todos los tests en verde]

    %% Phase 4: Application Layers (TDD Cycle)
    K --> L[TDD para la Capa de Servicios]
    L --> M[TDD para la Capa de API]
    
    %% Phase 5: Finalization
    M --> N[Implementar la Factory]
    N --> O[Configurar Pipeline de CI/CD para testear en ambas BDs]


    %% Styling
    classDef redPhase fill:#ffebee,color:#000000,stroke:#d32f2f,stroke-width:2px
    classDef greenPhase fill:#e8f5e8,color:#000000,stroke:#388e3c,stroke-width:2px
    classDef refactorPhase fill:#fff3e0,color:#000000,stroke:#f57c00,stroke-width:2px
    classDef interfacePhase fill:#e3f2fd,color:#000000,stroke:#1976d2,stroke-width:2px

    class A,B,C,D,E redPhase
    class F,G,H,I,J greenPhase
    class K refactorPhase
    class L,M,N,O interfacePhase
```

## Fases de Implementaci√≥n TDD

### Fase 1: Dise√±o de Interfaces (Interface First)

#### 1.1 ‚úÖ Entidades de Dominio

```typescript
// src/core/domain/entities/User.ts
export class User {
  constructor(
    public readonly id: string,
    public readonly email: Email,
    public readonly passwordHash: HashedPassword,
    public readonly role: Role,
    public readonly createdAt: Date,
    public readonly updatedAt: Date
  ) {
    this.validateConstructorParams();
  }

  // M√©todos de utilidad implementados
  canCreateContent(): boolean {
    return this.role.canCreateContent();
  }
  hasAdminPrivileges(): boolean {
    return this.role.hasAdminPrivileges();
  }
  isStudent(): boolean {
    return this.role.isStudent();
  }
  isContentCreator(): boolean {
    return this.role.isContentCreator();
  }
  isAdmin(): boolean {
    return this.role.isAdmin();
  }

  // Getters para APIs
  getEmailValue(): string {
    return this.email.value;
  }
  getRoleValue(): string {
    return this.role.value;
  }
  getPasswordHashValue(): string {
    return this.passwordHash.value;
  }
}
```

**Value Objects Implementados:**

- ‚úÖ `Email`: Validaci√≥n de formato de email
- ‚úÖ `HashedPassword`: Validaci√≥n de hash bcrypt
- ‚úÖ `PlainPassword`: Validaci√≥n de contrase√±a plana con reglas de fortaleza
- ‚úÖ `Role`: Roles de usuario con m√©todos de autorizaci√≥n

#### 1.2 ‚úÖ Interface del Repository

```typescript
// src/core/interfaces/repositories/IUserRepository.ts
export interface IUserRepository {
  create(userData: CreateUserData): Promise<User>;
  findById(id: string): Promise<User | null>;
  findByEmail(email: string): Promise<User | null>;
  update(id: string, updateData: UpdateUserData): Promise<User | null>;
  delete(id: string): Promise<void>;
}

export interface CreateUserData {
  email: string;
  passwordHash: string;
  role: string;
}

export interface UpdateUserData {
  email?: string;
  passwordHash?: string;
  role?: string;
}
```

### Fase 2: Tests de Contrato PRIMERO (RED)

#### 2.1 Escribir Tests ANTES de Implementar

```typescript
// src/core/interfaces/repositories/__tests__/IUserRepository.contract.test.ts
export function makeUserRepositoryContractTest(
  description: string,
  setupRepository: () => {
    repository: IUserRepository;
    cleanDatabase: () => Promise<void>;
    verifyUserInDatabase: (id: string) => Promise<boolean>;
  },
  teardownRepository: () => Promise<void>
) {
  // Tests de contrato que todas las implementaciones deben pasar
}
```

### Fase 3: Primera Implementaci√≥n (GREEN)

#### 3.1 Implementar UserRepository con Prisma para Pasar Tests

```typescript
// src/infrastructure/database/adapters/prisma/repositories/UserRepository.ts
export class UserRepository implements IUserRepository {
  constructor(private prisma: PrismaClient) {}
  // Implementaci√≥n usando Prisma que funciona con PostgreSQL y MySQL
}
```

#### 3.2 Tests de Integraci√≥n

```typescript
// __tests__/integration/postgresql/UserRepository.pg.test.ts
makeUserRepositoryContractTest(
  'UserRepository Integration Tests - PostgreSQL',
  () => ({
    repository: new UserRepository(testPrismaClient),
    cleanDatabase: () => TestDatabaseUtils.cleanDatabase(testPrismaClient),
    verifyUserInDatabase: async (id: string) => {
      const user = await testPrismaClient.user.findUnique({ where: { id } });
      return user !== null;
    },
  }),
  async () => {
    await TestDatabaseUtils.disconnectPrismaClient(testPrismaClient);
  }
);
```

```typescript
// __tests__/integration/mysql/UserRepository.mysql.test.ts
makeUserRepositoryContractTest(
  'UserRepository Integration Tests - MySQL',
  () => ({
    repository: new UserRepository(testPrismaClient),
    cleanDatabase: () => TestDatabaseUtils.cleanDatabase(testPrismaClient),
    verifyUserInDatabase: async (id: string) => {
      const user = await testPrismaClient.user.findUnique({ where: { id } });
      return user !== null;
    },
  }),
  async () => {
    await TestDatabaseUtils.disconnectPrismaClient(testPrismaClient);
  }
);
```

### Fase 4: Capa de Servicios

#### 4.1 Casos de Uso

```typescript
// src/core/use-cases/users/CreateUserUseCase.ts
export class CreateUserUseCase {
  constructor(
    @inject('IUserRepository') private userRepository: IUserRepository,
    @inject('IPasswordService') private passwordService: IPasswordService
  ) {}
}
```

#### 4.2 Implementaci√≥n del Servicio

```typescript
// src/modules/users/services/UserService.ts
export class UserService {
  constructor(
    private createUserUseCase: CreateUserUseCase,
    private updateUserUseCase: UpdateUserUseCase
  ) {}
}
```

### Fase 5: Capa de API

#### 5.1 DTOs y Validaci√≥n

```typescript
// src/modules/users/dto/CreateUserDto.ts
export const CreateUserSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
  role: z.enum(['student', 'content_creator', 'admin']),
});

export type CreateUserDto = z.infer<typeof CreateUserSchema>;
```

#### 5.2 Controladores

```typescript
// src/modules/users/controllers/UserController.ts
export class UserController {
  constructor(private userService: UserService) {}

  async create(req: Request, res: Response): Promise<void> {
    const userData = CreateUserSchema.parse(req.body);
    // Implementaci√≥n
  }
}
```

### Fase 6: Patr√≥n Factory

#### 6.1 Factory de Base de Datos

```typescript
// src/infrastructure/database/factories/DatabaseFactory.ts
export class DatabaseFactory {
  static createUserRepository(): IUserRepository {
    // Prisma maneja m√∫ltiples bases de datos con el mismo cliente
    // La configuraci√≥n se hace a nivel de schema y connection string
    return new UserRepository(prismaClient);
  }
}
```

**Configuraci√≥n Multi-Base de Datos con Prisma:**

```typescript
// src/infrastructure/database/config/prisma.config.ts
export const createPrismaClient = (): PrismaClient => {
  const databaseUrl = config.database.provider === 'postgresql' 
    ? config.database.postgresUrl 
    : config.database.mysqlUrl;
    
  return new PrismaClient({
    datasources: {
      db: { url: databaseUrl }
    }
  });
};
```

## Estrategia de Testing

### Matriz de Testing Multi-Base de Datos

| Tipo de Test         | PostgreSQL | MySQL | Prop√≥sito                            |
| -------------------- | ---------- | ----- | ------------------------------------ |
| Tests de Contrato    | ‚úÖ         | ‚úÖ    | Asegurar cumplimiento de interfaces  |
| Tests de Integraci√≥n | ‚úÖ         | ‚úÖ    | Validar operaciones de base de datos |
| Tests de Performance | ‚úÖ         | ‚úÖ    | Comparar rendimiento entre BDs       |
| Tests E2E            | ‚úÖ         | ‚úÖ    | Validaci√≥n de flujo completo         |

### Pipeline CI/CD

```yaml
# .github/workflows/ci.yml
strategy:
  matrix:
    database: [postgresql, mysql]
    node-version: [22.x]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
      - name: Install dependencies
        run: npm ci
      - name: Run integration tests
        run: npm run test:integration:${{ matrix.database }}
```

## Principios TDD Aplicados

### Ciclo Red-Green-Refactor

1. **üî¥ RED**: Escribir un test que falle
   - Definir el comportamiento esperado ANTES de implementar
   - Los tests act√∫an como especificaci√≥n ejecutable
   - Garantiza que el test realmente valida la funcionalidad

2. **üü¢ GREEN**: Escribir el c√≥digo m√≠nimo para pasar el test
   - Implementar solo lo necesario para que el test pase
   - No optimizar prematuramente
   - Enfocarse en hacer que funcione

3. **üü° REFACTOR**: Mejorar el c√≥digo sin cambiar funcionalidad
   - Limpiar el c√≥digo manteniendo los tests verdes
   - Aplicar patrones de dise√±o
   - Optimizar performance si es necesario

### Aplicaci√≥n en Nuestro Proyecto

- **Tests de Contrato**: Definen el comportamiento que la implementaci√≥n debe cumplir en ambas BDs
- **Implementaci√≥n √önica**: Una sola implementaci√≥n con Prisma funciona en PostgreSQL y MySQL
- **Validaci√≥n Continua**: Los tests garantizan que la implementaci√≥n funciona consistentemente en ambas BDs

## Beneficios Clave

1. **TDD Aut√©ntico**: Tests escritos ANTES que implementaciones, dirigiendo el dise√±o
2. **Agn√≥stico de Base de Datos**: Cambiar entre PostgreSQL y MySQL sin modificar la l√≥gica de negocio
3. **Cumplimiento de Contratos**: Una implementaci√≥n garantizada para funcionar consistentemente en ambas BDs
4. **Calidad por Dise√±o**: Los tests act√∫an como especificaci√≥n ejecutable
5. **Refactoring Seguro**: Cambios con confianza gracias a la cobertura de tests
6. **Arquitectura Limpia**: Separaci√≥n clara de responsabilidades
7. **Simplicidad**: Una sola implementaci√≥n con Prisma reduce complejidad y mantenimiento
8. **Testcontainers**: Tests de integraci√≥n con bases de datos reales en contenedores ef√≠meros

## Orden de Implementaci√≥n TDD (Red-Green-Refactor)

### Ciclo 1: Repository Layer

1. ‚úÖ **RED**: Definir interfaces y escribir tests de contrato (IMPLEMENTADO)
2. ‚úÖ **RED**: Crear suite de tests que debe pasar la implementaci√≥n (IMPLEMENTADO)
3. ‚úÖ **GREEN**: Implementar UserRepository con Prisma para PostgreSQL (IMPLEMENTADO)
4. ‚úÖ **GREEN**: Validar que la misma implementaci√≥n funciona con MySQL (IMPLEMENTADO)
5. ‚úÖ **REFACTOR**: Optimizar implementaci√≥n y configuraci√≥n multi-BD (IMPLEMENTADO)

**Estado Actual del Proyecto:**

**Domain Layer:**
- ‚úÖ User entity con validaciones completas
- ‚úÖ Value objects: Email, Password (Plain/Hashed), Role
- ‚úÖ IUserRepository interface definida
- ‚úÖ Tests unitarios para User entity
- ‚úÖ Tests de contrato para IUserRepository

**Repository Layer:**
- ‚úÖ UserRepository implementado con Prisma
- ‚úÖ Tests de integraci√≥n con PostgreSQL funcionando
- ‚úÖ Tests de integraci√≥n con MySQL funcionando
- ‚úÖ Testcontainers configurado para ambas BDs
- ‚úÖ Configuraci√≥n de Jest para m√≥dulos ES (uuid) resuelta

### Ciclo 2: Service Layer

7. üîÑ **RED**: Escribir tests de servicios y casos de uso PRIMERO
8. üîÑ **GREEN**: Implementar servicios para pasar tests
9. üîÑ **REFACTOR**: Optimizar inyecci√≥n de dependencias

### Ciclo 3: API Layer

10. üîÑ **RED**: Escribir tests de controladores y validaci√≥n PRIMERO
11. üîÑ **GREEN**: Implementar controladores y DTOs para pasar tests
12. üîÑ **REFACTOR**: Optimizar validaci√≥n con Zod

### Ciclo 4: Factory Pattern

13. üîÑ **RED**: Escribir tests de factory pattern PRIMERO
14. üîÑ **GREEN**: Implementar factory para pasar tests
15. üîÑ **REFACTOR**: Configurar CI/CD con testing multi-base de datos

## Pr√≥ximos Pasos Inmediatos

### Fase Actual: Service Layer (Pr√≥ximo Ciclo TDD)

**Repository Layer Completado:**
1. ‚úÖ **UserRepository implementado** con Prisma funcionando en PostgreSQL y MySQL
2. ‚úÖ **Tests de contrato pasando** en ambas bases de datos
3. ‚úÖ **Tests de integraci√≥n** con Testcontainers configurados
4. ‚úÖ **Configuraci√≥n de Jest** para m√≥dulos ES resuelta

### Siguientes Fases:

- **Service Layer**: Implementar casos de uso con inyecci√≥n de dependencias
- **API Layer**: Crear DTOs, validaci√≥n con Zod y controladores HTTP
- **Factory Pattern**: Configurar selecci√≥n din√°mica de base de datos
- **Performance Testing**: Benchmarking entre PostgreSQL y MySQL
- **CI/CD Pipeline**: Automatizar tests en ambas bases de datos
- **Documentaci√≥n API**: OpenAPI/Swagger para endpoints

### Estado Actualizado del Proyecto:

- ‚úÖ **Domain Layer**: Completamente implementado con TDD
- ‚úÖ **Repository Layer**: Implementado y validado en PostgreSQL y MySQL
- üîÑ **Service Layer**: Pr√≥ximo en implementar
- üîÑ **API Layer**: Pendiente
- üîÑ **Factory Pattern**: Pendiente

### Configuraci√≥n de Testing Actual:

```bash
# Tests unitarios
npm run test:unit

# Tests de integraci√≥n PostgreSQL
npm run test:integration:postgres

# Tests de integraci√≥n MySQL  
npm run test:integration:mysql

# Tests en ambas bases de datos
npm run test:all-dbs
```

**Resultados de Testing:**
- ‚úÖ PostgreSQL: 2 test suites passed, 10 tests passed
- ‚úÖ MySQL: 2 test suites passed, 10 tests passed
- ‚úÖ UUID ES module issue: Resuelto con wrapper CommonJS
- ‚úÖ Testcontainers: Funcionando correctamente
